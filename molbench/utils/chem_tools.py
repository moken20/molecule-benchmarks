import numpy as np


def sitevec_to_fock(det, format):
    r"""Covert a Slater determinant from site vector to occupation number vector representation.

    Args:
        det (list): determinant in site vector representation
        format (str): the format of the determinant

    Returns:
        tuple: tuple of integers representing binaries that correspond to occupation vectors in
            alpha and beta spin sectors

    **Example**

    >>> det = [1, 2, 1, 0, 0, 2]
    >>> sitevec_to_fock(det, format = 'dmrg')
    (5, 34)

    >>> det = ["a", "b", "a", "0", "0", "b"]
    >>> sitevec_to_fock(det, format = 'shci')
    (5, 34)
    """

    if format == "dmrg":
        format_map = {0: "00", 1: "10", 2: "01", 3: "11"}
    elif format == "shci":
        format_map = {"0": "00", "a": "10", "b": "01", "2": "11"}

    strab = [format_map[key] for key in det]

    stra = "".join(i[0] for i in strab)
    strb = "".join(i[1] for i in strab)

    inta = int(stra[::-1], 2)
    intb = int(strb[::-1], 2)

    return inta, intb

def get_mol_attrs(mol):
    '''
    Simple extractor to compute often used molecular properties. Returns
    the number of molecular orbitals (NOT spin-orbitals), and the number of
    electrons of both alpha and beta type, depending on the spin. By default,
    takes nelec_a > nelec_b to satisfy spin conditions.
    '''
    norb = mol.nao
    nelec = mol.nelectron
    nelec_a = int( (nelec + mol.spin)/2 )
    nelec_b = int( (nelec - mol.spin)/2 )

    return norb, nelec_a, nelec_b


def _excitations(electrons, orbitals):
    r"""Generate all possible single and double excitations from a Hartree-Fock reference state.

    This function is a more performant version of ``qchem.excitations``, where the order of the
    generated excitations is consistent with PySCF.

    Single and double excitations can be generated by acting with the operators
    :math:`\hat T_1` and :math:`\hat T_2` on the Hartree-Fock reference state:

    .. math::

        && \hat{T}_1 = \sum_{p \in \mathrm{occ} \\ q \in \mathrm{unocc}}
        \hat{c}_q^\dagger \hat{c}_p \\
        && \hat{T}_2 = \sum_{p>q \in \mathrm{occ} \\ r>s \in
        \mathrm{unocc}} \hat{c}_r^\dagger \hat{c}_s^\dagger \hat{c}_p \hat{c}_q.


    In the equations above the indices :math:`p, q, r, s` run over the
    occupied (occ) and unoccupied (unocc) *spin* orbitals and :math:`\hat c` and
    :math:`\hat c^\dagger` are the electron annihilation and creation operators,
    respectively.

    Args:
        electrons (int): number of electrons
        orbitals (int): number of spin orbitals

    Returns:
        tuple(list, list): lists with the indices of the spin orbitals involved in the excitations

    **Example**

    >>> electrons = 2
    >>> orbitals = 4
    >>> _excitations(electrons, orbitals)
    ([[0, 2], [0, 3], [1, 2], [1, 3]], [[0, 1, 2, 3]])
    """
    singles_p, singles_q = [], []
    doubles_pq, doubles_rs = [], []

    for i in range(electrons):
        singles_p += [i]
        doubles_pq += [[k, i] for k in range(i)]
    for j in range(electrons, orbitals):
        singles_q += [j]
        doubles_rs += [[k, j] for k in range(electrons, j)]

    singles = [[p] + [q] for p in singles_p for q in singles_q]
    doubles = [pq + rs for pq in doubles_pq for rs in doubles_rs]

    return singles, doubles


def excited_configurations(electrons, orbitals, excitation):
    r"""Generate excited configurations from a Hartree-Fock reference state.

    This function generates excited configurations in the form of integers representing a binary
    string, e.g., :math:`|1 1 0 1 0 0 \rangle` is represented by :math:`int('110100', 2) = 52`.

    The excited configurations are generated from a Hartree-Fock (HF) reference state. The HF state
    is assumed to have the form :math:`|1 1 ...1 0 ... 0 0 \rangle` where the number of :math:`1`
    and :math:`0` elements are the number of occupied and unoccupied spin orbitals, respectively.
    The string representation of the state is obtained by converting the occupation-number vector to
    a string, e.g., ``111000`` to represent :math:`|1 1 1 0 0 0 \rangle.

    Each excited configuration has a sign, :math:`+1` or :math:`-1`, that is obtained by reordering
    the creation operators.

    Args:
        electrons (int): number of electrons
        orbitals (int): number of spin orbitals
        excitation (int): number of excited electrons

    Returns:
        tuple(list, list): lists of excited configurations and signs obtained by reordering the
         creation operators

    **Example**

    >>> electrons = 3
    >>> orbitals = 5
    >>> excitation = 2
    >>> excited_configurations(electrons, orbitals, excitation)
    ([28, 26, 25], [1, -1, 1])
    """
    if excitation not in [1, 2]:
        raise ValueError(
            "Only single (excitation = 1) and double (excitation = 2) excitations are supported."
        )

    hf_state = np.array(np.where(np.arange(orbitals) < electrons, 1, 0))
    singles, doubles = _excitations(electrons, orbitals)
    states, signs = [], []

    if excitation == 1:
        for s in singles:
            state = hf_state.copy()
            state[s] = state[[s[1], s[0]]]  # apply single excitation
            states += [state]
            signs.append((-1) ** len(range(s[0], electrons - 1)))

    if excitation == 2:
        for d in doubles:
            state = hf_state.copy()
            state[d] = state[[d[2], d[3], d[0], d[1]]]  # apply double excitation
            states += [state]
            order_pq = len(range(d[0], electrons - 1))
            order_rs = len(range(d[1], electrons - 1))
            signs.append((-1) ** (order_pq + order_rs + 1))

    states_str = ["".join([str(i) for i in state]) for state in states]
    states_int = [int(state[::-1], 2) for state in states_str]

    return states_int, signs


def verify_active_space(mol, ncas, nelecas):
    spin = mol.spin
    norb, nelec_a, nelec_b = get_mol_attrs(mol)
    n_active_a, n_active_b = nelecas
    ncore_e = nelec_a + nelec_b - n_active_a - n_active_b

    # Basic sanity checks
    if n_active_a < 0 or n_active_b < 0:
        raise ValueError(f"Active electrons must be non-negative, got {nelecas}.")
    if n_active_a > ncas or n_active_b > ncas:
        raise ValueError(
            f"Active electrons {nelecas} exceed active orbitals ncas={ncas} "
            f"(need n_active_a<=ncas and n_active_b<=ncas)."
        )
    if (n_active_a + n_active_b) > 2 * ncas:
        raise ValueError(
            f"Too many active electrons: {nelecas} for ncas={ncas} (max is 2*ncas={2*ncas})."
        )
    if not ncore_e % 2 == 0:
        raise ValueError(
            f"Only even numbers of electrons in the core are allowed."
        )
    ncore_orb = ncore_e // 2
    # In general, the MO space is partitioned as: core (ncore_orb) + active (ncas) + virtual.
    # Virtual orbitals are allowed; we only need that core+active fit in the available orbitals.
    if (ncore_orb + ncas) > norb:
        raise ValueError(
            f"Active space does not fit: core_orb={ncore_orb} + ncas={ncas} > norb={norb}. "
            f"(Derived from total electrons={nelec_a+nelec_b} and active electrons={nelecas})"
        )
    if not (n_active_a - n_active_b == spin):
        raise ValueError(
            f"Active electrons {nelecas} must agree with molecule spin {spin} used in HF calculation."
        )